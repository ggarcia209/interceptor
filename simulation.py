""" simulation.py takes n amount of values (where n == # of seconds sim runs) generated by TestValues class
and simulates the real-life application of Interceptor - returning new stats once every second. """

import time

from interceptor import Intercept
from test_values import TestValues
from collections import defaultdict


class Simulation():
    def __init__(self):
        self.moving_avgs = defaultdict(list)

    def get_values(self):
        """ Generates values from TestValues. """
        self.test = TestValues()
        self.test.create_test()
        return self.test.values

    def run_sim(self):
        """ Creates sim by creating n instances of Interceptor and
        returns results Interceptor calculations for each instance. """
        self.outputs = {"times": [], "gaps": [], "nets": []}
        for i, val in enumerate(self.test.values["s1_value"]):
            op = Intercept(self.test.values["d_value"][i], self.test.values["s1_value"][i],
                           self.test.values["s2_value"][i])
            op.get_time()
            op.get_distance()
            self.outputs["times"].append(op.time)
            self.outputs["gaps"].append(op.gap)
            self.outputs["nets"].append(op.net_distance)
        return self.outputs

    def calculate_moving_avgs(self, values, key_name='default', start=0, multiple=10):
        """ Calculates moving averages for k seconds, where k == multiple (10 by default). """
        segs = []
        beg = start
        if beg < 0:
            beg = 0
        end = start + multiple
        for _ in range(len(values) - multiple + 1):
            seg = sum(values[beg:end])
            segs.append(seg)
            beg += 1
            end += 1
        for value in segs:
            avg = value / multiple
            self.moving_avgs[key_name].append(avg)
        return self.moving_avgs

    def get_percentage(self):
        """ Calculates and returns percentage of initial distance closed by interceptor vehicle.
        percentage can be greater than 100 if current distance > initial distance. """
        self.percentages = []
        for i in range(len(self.test.values["d_value"])):
            percentage = round(((self.test.values["d_value"][i] / self.test.initial_distance) * 100), 2)
            self.percentages.append(percentage)
        return self.percentages

    def convert_times(self):
        """ Converts times returned by Intercept instance in seconds to minutes:seconds.milliseconds """
        mins = []
        secs = []
        self.converted_times = []
        for time_value in self.outputs["times"]:
            minute = int(time_value / 60)
            mins.append(minute)
            secs.append(round(((time_value / 60) - minute) * 60, 3))
        for i in range(len(mins)):
            if secs[i] < 10:
                secs[i] = str("0{}".format(secs[i]))
            else:
                secs[i] = str(secs[i])
            self.converted_times.append("{}:{}".format(mins[i], secs[i]))
        return self.converted_times

    def display_stats(self, mavg_period=10):
        """ Displays live stats for user based on values at each second. """
        indx = 0
        try:
            for value in self.converted_times:
                print("""
    Time until intercept: {} """.format(value), "\r")
                print("""
    Distance: {} kilometers""".format(round(self.outputs["gaps"][indx] / 1000, 2)))
                print("\r")
                print("Percentage: {}/100".format(self.percentages[indx]))
                print("Count: {}".format(indx), "\r")
                print("\r")
                if indx >= mavg_period:
                    print(
                        "Moving average: Meters: {}".format(round(self.moving_avgs["distance"][indx - mavg_period], 2)))
                    print("Moving average: Seconds: {}".format(round(self.moving_avgs["time"][indx - mavg_period], 2)))
                else:
                    print("Getting data...")
                    print("\r")
                print("-" * 15)
                indx += 1
                time.sleep(1)
        except IndexError:
            pass

    def start_sim(self):
        """ Creates and starts sim with one command. """
        self.get_values()
        self.run_sim()
        self.calculate_moving_avgs(self.outputs["times"], "time")
        self.calculate_moving_avgs(self.outputs["gaps"], "distance")
        self.get_percentage()
        self.convert_times()
        self.display_stats()
